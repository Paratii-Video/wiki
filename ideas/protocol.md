# Disintermediation

Youtube is a big black box.
**Creators** send videos to that box in exchange for an audience and a part of advertisement sales that are generated by their content - but creators have very little control over what they earn or how their content is presented.
**Viewers** send their personal data and their "attention" to the Youtube box, and in exchange get access to the uploaded content, but they have little control over what happens to their data, or over how their attention is "spent" (e.g. over the kind of advertisement they see).
**Advertisers** pay Youtube to show advertisements to users, but have no way of auditing the numbers that Youtube presents them.


**Disintermediation** means redefining an economic system in such a way that economic interactions occur as much as possible directly between the agents involved, without intermediaries.
Econommic transactions should be as much as possible on a peer-to-peer basis.

The idea is that disintermediation will (1) **lower the costs** for the agents involved and (2) gives the agents **more choice and more control** over how much they spend or earn, or over which data they share.

In the case of Video distribution, those actors are viewers, creators, curators, advertisers, providers of services such as transcoding and storage, nodes in a CDN, etc.

Below, we describe a generic protocol schema, a variant of the 0x protocol, which makes it possible to create an open market for the various type of interactions that occur.

We think that creating a open market for all these services involved can make (a) the market more efficient and fair, which translates in lower costs for advertisers and more revenue for creators and (b) give viewers more control over their data and give advertisers better insight into the audience they reach.

# Overview

In the **Base Layer** protocol every agent pays for what he consume directly to the agent providing the service. I.e. you want to transcode a video? You pay a transcoder. You want to store it? You pay for that. You want to watch a video? You pay for CDN; you pay the creator for his content (if the creator wants that).
Advertisers pay viewers directly for their time.

This base layer provides the basic rules of the video economy, where viewers, uploaders, creators, aggregators, transcoders, storers, cdn-nodes interact as peers.

An **Application layer** will be built on top of the base layer that provides higher level services consisting of combinations of base layer transcations.

For example, on can create a Youtube-like experience, in which viewers get to see the content for "free" - meaning, in this case, that they pay for it by viewing advertisements and giving their personal data.
We can reproduce that experience: when the user needs to pay something, the app can (as transparant as possible) get some money to pay with, buy, for example, showing an ad, or seeding some content, or asking for some curation work.

The base layer contains combinations of the base-level transactions, built either by Paratii or by 3rd parties on top of the base layer protocol. Watching a video+ad "for free" in yt style means that your app will do a whole series of negotations: make an offer for an add, find an interstitial ad, negotiate conditions, get some advance money from the advertiser (or some credit provider) to see your first 20s of vid, watch the ad, get paid for it, watch the rest of the video.

# A Paratii Video Protocol


[This part draws on [my ideas for the advertisement market]( https://github.com/Paratii-Video/wiki/wiki/A-market-for-Sybils)  and  [Felipes idea of using the 0x mechanisms](https://medium.com/paratii/what-if-0x-could-be-used-for-decentralised-real-time-bidding-advertising-9fcb733d8e84) a bit further by generalizing the idea and use it for all client-activated requests in the Paratii framework. I'll also try to be a bit more precise about how to handle claims that cannot be resolved onchain (such as "proof-of-view")]



## 0x

Roughly, the idea of 0x can be described as follows.

**Orders** are messages that are statements of intent, like "I want to sell 3 bananas for 1 dollar". Orders are submitted and signed by a  **maker**.  Orders are then aggregated by **relayers**, which collect orders and try to find counterparties - **takers** - that fulfill the orders.

To fulfill the order, the taker submits the order to a smart contract.
A precondition for fulfilling the order is that both maker and taker have giving this contract can transfer the tokens referred to in the order.

The smart contract checks the validity of the data - in particular, the signature of the maker and the preconditions for the resulting transfers - and executes  the order.

The 0x protocol concerns orders - typically, trades of ERC20 tokens - that can be completely settled on-chain. When an order is matched and signed, all information is there for the order to be settled.
In the setup we describe here, orders can be much more generic. For example, they can be requests for "real-world" services such as transcoding or storage.  Or they can be requests where a user offers to watch an advertisement in exchange for a payment. Such requests necessity have an off-chain component.


## Generalizing 0x

One idea behind the 0x protocol is that actors can signal and (to an extent) *commit to*  intentions and needs by cryptographically signing messages, messages which then can be combined and settled on the blockchain.

We generalize the mechanisms of the 0x protocol in order to use it for many types of "trades" that occur in the video pipeline - for example, requests for services such transcoding or storage, and even for more complex exchanges, such as that of trading attention to an advertisement in exchange for a compensation.

We do that by

  (a) extending the message format somewhat to allow for different **order types** (as proposed in ZEIP4) and a generic **data** field, and
  (b) generic class of "settlement" procedures, captured by smart contracts

The general schema is this:

* an **order** is an array  with fields like:

  - orderType : the type of order that is (ZEIP4)
  - makerToken
  - makertokenAmount: the (max) amount of tokens that the sender is willing to pay
  - taker: (ZEIP??) can be different from the sender, and can further specify  [perhaps not needed if we use orderType]
  - takerToken
  - takerTokenAmont
  - data: a generic structure that can contain further data related to the orderType
  - a signature of the maker that signs the message

## Order types

Each order type comes with:

* a specification of the data structure of the order
* a specification of the smart contract used to fullfill the order (its address is tht of the `taker` field)

### `VIDEO_SUBMIT` submit a video

Request to add a video to a listing:

    {
      orderType: `VIDEO_SUBMIT`,
      data:  {
        hash: '0x...', // (ipfs) hash of the video submitted
        author: 0x.. , // address of the author
        hashData: 0x..., // IPFSHash with further data on the video
        listId: 0x..., // an identifier of the list where the video is to be submitted
      },
      makerTokenAmount: 1234 // the amount the maker is willing to stake on this video (can be 0)
      takerTokenAmount: null //  the taker must at least fill the bid for `stake - makerTokenAmount`
    }

Listings may be of different kinds.
We'll describe the case where the listing is a TCR.

The takers role here is to provide the (additional) capital needed for staking in the TCR, and to submit the TCR request.

The smart contract will fulfill this order by (a) creating an onchain record for the video in the `Videos.sol` contract and (b) submit the identifier to the TCR.

There are different scenarios where this can be useful:
- video makers can set `makerTokenAmount` to 0, i.e. submit videos completely for free (having "professionals" handle the staking part)
- video makers can submit videos with a stake in tokens; and stakeholders in the TCR can pay transaction fees (this is useful for platforms that want to reduce friction to pay the transaction fees for their users)

[there is a complication here in that the TCR will not allow a "split deposit", so the contract should handle that as well]

Note that all these actions can also be executed directly by the maker himself, bypassing the relayer and the relayer's contract.
For the `VIDEO_SUBMIT` orderType, the relayer serves as a way to provide new ways of paying for transaction costs and staking, a uniform interface in the Paratii framework, but does not provide an essential service.

There is a complementary `VIDEO_CHALLENGE` action that functions as a request to "crowdfund" a challenge, and a `VIDEO_EXIT` which is a request to remove the video from the listing entirely.


## `TRANSCODING_REQUEST`

Request that the video be transcoded.

    {
      orderType: `TRANSCODING_REQUEST`,
      data: {
        hash: '0x...', // ipfs hash of the file to be transcoded [may make this an url]
        ... information about max price, quality, timing, etc etc
      },
      makerTokenAmount: 1234 // (maximal) amount offered by the maker for transcoding this
    }

Relayers match the transcoding request with a transcoder or transcoding machinery. We can here think of interesting market interactions and price discovery, where relayers will match the order type with a transcoder that asks less than `makerTokenAmount`, and is allowed to keep the difference between actual cost and makerTokenAmount.

##  `PIN_REQUEST` plz pin this file. Will come with times, prices, etc.

This is very similar to the transcoding request, except that the `data` field will contain requested conditions for the pinning of the file (time, guarantees, etc)

## `AD_REQUEST` we have a view and would like to insert an Ad before


The viewer offers to view an advertisement in exchange for a payment from the advertiser.

    {
      orderType: `AD_REQUEST`,
      data: {
        // anything that may convince the advertiser that the risk to provide this ad in return for takerTokenAmount is worth taking
        why : '....',  
        what: '...',  // a description of what kind of ad the maker is willing to watch, conditions on the reputation of the advertiser, stuff like that
        contactInfo: '..', // i.e. the ipfs or whisper enode address of the maker
      },
      takerTokenAmount: .. , // the amount the maker wants to be paid for watching the advertisement makerTokenAmount: 0,
    }

The viewer here is offering to spend some future time in watching the advertisment, and must convince the advertiser that his attention is worth the `takerTokenAmount`.
The data field contains evidence that the ask price is justified.
The viewer can offer as much evidence as she likes: for example, she can share personal information about here age or location (or would be a link to a identity provider) that helps the advertiser targeting the ad, she may link to a reputation system to prove that she is in good standing, she may share past viewing history; and information about this particular request (such as IP address). She can also specifity the taker of the offer - i.e. making an offer to a particular advertiser that perhaps she has done business with before. In general, **the more information she provides, the more valuable her offer is**.

Putting this kind of information on an open market is at odds with any **privacy**  requirements the user may have.  Sharing information is voluntary, but the fact that the information is public might be a reason not to share that information at all, and this means that she will get paid less than she might have been.
This can be mitigated by allowing the user to encrypt (part of) the data offered. A potential buyer can then (privately) as the viewer for the key, which she can provide if she trusts this particular advertiser.

The data field may also contain information about the kind advertisement that the viewer is willing to watch, such as its duration, or its type.

Fulfilling this order is a multi-step process:

- Before accepting an order, viewer and advertiser negotiate over the precise conditions of the deal. What ad is the viewer going to watch? Where will it be shown? What kind of evidence does the advertiser need for payout?
- The advertiser and maker mutually sign a message with details about the agreement.
- After watching the video, the viewer submits a "proof of view" with evidence that she has actually watched the ad.
- If there is no disagreement, the taker simply signs the original order and submits it to the smart contract.

In case of disagreement, an arbitrage procedure is started.s
This means that the viewer submits the original order together with the "proof of view" to an Arbiter.
[and we enter into a whole new rabbit hole, but that is "out of scope" here :-)]

## `DATA`

Aggregated data on users is very valuable. Viewers may put their past viewing history for sale - as anonimized as they feel comfortable with. This would take the form of an order in which a viewers offers encrypted data with a description for sale - and when an offer is matched, the viewer will send the key to the buyer.

## `LIKE`

In the case of a `LIKE` orderType, the viewer is offering to contribute to the curation of a list. This information may be worth something to aggregators or list creators, or other analysts.
Because the viewer is offering a piece of information, we cannot include the info itself into the order. Instead, the viewer will offer a *commitment* to a like or dislike, which she will reveal once the offer is accepted.

    {
      orderType: 'LIKE',
      data: {
        'proof': ... // "proof" of the like -i.e. sustaining evidence that the like is real
        commitment:   ..// hash of a yes/no answer + salt
        contactInfo: ... // contactinfo of the maker
      }
      makerTokenAmount: ., // the amount the maker would like to be paid for this "curation act"
      takerTokenAmount: 0,
    }

Here we can do the usual commit-reveal scheme with a twist: taker accepts the order and signs it. Maker accepts the taker-signed order, reveals the commit, and submits the whole shebang to a smart contract that will check the signatures, etc.

This is a kind of generic schema for selling information. First, the seller provides the encrypted data together with a "proof" that the data is actually there (the "proof" could be simply a informal statement that the signer is a reputable source, but can also be a Zero-knowledge proof that, say, the encrypted data represents the solution to a given problem), the buyer signs the offer, and at that point, the seller sends the reveal together with the doubly-signed transaction to a smart contract on the blockchain. The contract checks if the reveal indeed corresponds to the commit, checks the signatures, and pays the seller. [* this has  a"frontrunning" bug in that the buyer could find the transaction in the mempool, see the reveal, and quickly withrdraw his funds to the smart contract cannot pay the sller anymore]
